{{ .LeadingComments }}

package {{ $.Package }}

import (
{{- if gt (len .Concerns) 0 }}
	"bytes"
	"context"
	"fmt"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	"github.com/lachlanorr/rocketcycle/pkg/rkcy"
{{- end }}
)
{{- if gt (len .Configs) 0 }}
{{ range $config := .Configs }}
// TODO: Config stuff for {{ $config.Name }}
{{- end }}
{{- end }}
{{- if gt (len .Concerns) 0 }}
{{ range $cnc := .Concerns }}
{{- $relConfArg := "" }}
{{- $relConfType := "" }}
{{- $relCncArg := "" }}
{{- $relCncType := "" }}
{{- with $cnc.RelConfigs }}
{{- $relConfArg = printf "relatedConfigs *%s, " $cnc.RelConfigs.Msg.Name }}
{{- $relConfType = printf "*%s, " $cnc.RelConfigs.Msg.Name }}
{{- end }}
{{- with $cnc.RelConcerns }}
{{- $relCncArg = printf "relatedConcerns *%s, " $cnc.RelConcerns.Msg.Name }}
{{- $relCncType = printf "*%s, " $cnc.RelConcerns.Msg.Name }}
{{- end }}
// -----------------------------------------------------------------------------
// Concern {{ $cnc.Name }}
// -----------------------------------------------------------------------------
func init() {
	rkcy.RegisterConcernHandler(&{{ $cnc.Name }}ConcernHandler{})
}

// StorageCommands Interface
type {{ $cnc.Name }}StorageCommands interface {
	Read(ctx context.Context, key string) (*{{ $cnc.Name }}, {{ $relConfType }}*rkcy.CompoundOffset, error)
	Create(ctx context.Context, inst *{{ $cnc.Name }}, cmpdOffset *rkcy.CompoundOffset) error
	Update(ctx context.Context, inst *{{ $cnc.Name }}, {{ $relCncArg }}cmpdOffset *rkcy.CompoundOffset) error
	Delete(ctx context.Context, key string, cmpdOffset *rkcy.CompoundOffset) error
}

// ProcessCommands Interface
type {{ $cnc.Name }}ProcessCommands interface {
	ValidateCreate(ctx context.Context, inst *{{ $cnc.Name }}) (*{{ $cnc.Name }}, error)
	ValidateUpdate(ctx context.Context, original *{{ $cnc.Name }}, updated *{{ $cnc.Name }}) (*{{ $cnc.Name }}, error)
{{- with $cnc.Commands }}
{{ range $cmd := $cnc.Commands }}
	{{ $cmd.Name }}(ctx context.Context, inst *{{ $cnc.Name }}{{ $relCncArg }}{{ if $cmd.HasInput }}, payload *{{ $cmd.InputType }}{{ end }}) ({{ if $cmd.HasOutput }}*{{ $cmd.OutputType }}, {{ end }}error)
{{- end }}
{{- end }}
}

// Concern Handler
type {{ $cnc.Name }}ConcernHandler struct{
     storageCmds map[string]{{ $cnc.Name }}StorageCommands
     processCmds {{ $cnc.Name }}ProcessCommands
}

func (*{{ $cnc.Name }}ConcernHandler) ConcernName() string {
	return "{{ $cnc.Name }}"
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) SetStorageCommands(storageSystem string, commands interface{}) error {
	cmds, ok := commands.({{ $cnc.Name }}StorageCommands)
	if !ok {
	   return fmt.Errorf("Invalid interface for {{ $cnc.Name }}ConcernHandler.SetStorageCommands: %T", commands)
	}
	if cncHdlr.storageCmds == nil {
		cncHdlr.storageCmds = make(map[string]{{ $cnc.Name }}StorageCommands)
	}
	_, ok = cncHdlr.storageCmds[storageSystem]
	if ok {
	   return fmt.Errorf("StorageCommands already registered for %s/{{ $cnc.Name }}ConcernHandler", storageSystem)
	}
	cncHdlr.storageCmds[storageSystem] = cmds
	return nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) SetProcessCommands(commands interface{}) error {
	if cncHdlr.processCmds != nil {
	   return fmt.Errorf("ProcessCommands already registered for {{ $cnc.Name }}ConcernHandler")
	}
	var ok bool
	cncHdlr.processCmds, ok = commands.({{ $cnc.Name }}ProcessCommands)
	if !ok {
	   return fmt.Errorf("Invalid interface for {{ $cnc.Name }}ConcernHandler.SetProcessCommands: %T", commands)
	}
	return nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) ValidateCommands() bool {
	if cncHdlr.processCmds == nil {
    	return false
    }
    if cncHdlr.storageCmds == nil || len(cncHdlr.storageCmds) == 0 {
		return false
	}
    return true
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) HandleCommand(
	ctx context.Context,
	system rkcy.System,
	command string,
	direction rkcy.Direction,
	args *rkcy.StepArgs,
	instanceStore *rkcy.InstanceStore,
    storageSystem string,
) *rkcy.ApecsTxn_Step_Result {
	var err error
	rslt := &rkcy.ApecsTxn_Step_Result{}

	if direction == rkcy.Direction_REVERSE && args.ForwardResult == nil {
		rslt.SetResult(fmt.Errorf("Unable to reverse step with nil ForwardResult"))
		return rslt
	}

	if system == rkcy.System_PROCESS {
		switch command {
		// process handlers
		case rkcy.VALIDATE_CREATE:
			{
				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				payloadOut, err := cncHdlr.processCmds.ValidateCreate(ctx, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
			}
		case rkcy.VALIDATE_UPDATE:
			{
				instBytes := instanceStore.GetInstance(args.Key)
            	if instBytes == nil {
					rslt.SetResult(fmt.Errorf("No instance exists during VALIDATE_UPDATE"))
					return rslt
				}
				inst := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(instBytes, inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}

				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				payloadOut, err := cncHdlr.processCmds.ValidateUpdate(ctx, inst, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}

				// compare inst to see if it has changed
				instSer, err := proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				if !bytes.Equal(instSer, args.Instance) {
					rslt.Instance = instSer
				}
			}
{{- range $cnc.Commands }}
		case "{{ .Name }}":
			{
				instBytes := instanceStore.GetInstance(args.Key)
            	if instBytes == nil {
					rslt.SetResult(fmt.Errorf("No instance exists during HandleCommand"))
					return rslt
				}
				inst := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(instBytes, inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}

				{{- with $cnc.RelConcerns }}
				related := &{{ $cnc.RelConcerns.Msg.Name }}{}
                relatedBytes := instanceStore.GetRelated(args.Key)
                if relatedBytes != nil {
       				err = proto.Unmarshal(relatedBytes, related)
                }
				{{- end }}
				{{- if .HasInput }}
				payloadIn := &{{ .InputType }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				{{- end }}
				{{ if .HasOutput }}payloadOut, {{ end }}err := cncHdlr.processCmds.{{ .Name }}(ctx, inst{{ with $cnc.RelConcerns }}, related{{ end }}{{ if .HasInput }}, payloadIn{{ end }})
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				{{- if .HasOutput }}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				{{- end }}

				// compare inst to see if it has changed
				instSer, err := proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				if !bytes.Equal(instSer, args.Instance) {
					rslt.Instance = instSer
				}
			}
{{- end }}
		default:
			rslt.SetResult(fmt.Errorf("Invalid process command: %s", command))
			return rslt
		}
    } else if system == rkcy.System_STORAGE {
		// Quick out for REVERSE mode on non CREATE commands, this should never happen
		if direction == rkcy.Direction_REVERSE && command != rkcy.CREATE {
			rslt.SetResult(fmt.Errorf("Unable to reverse non CREATE storage commands"))
            return rslt
		}

        cmds, ok := cncHdlr.storageCmds[storageSystem]
        if !ok {
	       rslt.SetResult(fmt.Errorf("No storage commands for %s", storageSystem))
           return rslt
	    }

		switch command {
		// storage handlers
		case rkcy.CREATE:
			{
				if direction == rkcy.Direction_FORWARD {
					payloadIn := &{{ $cnc.Name }}{}
					err = proto.Unmarshal(args.Payload, payloadIn)
					if err != nil {
						rslt.SetResult(err)
						return rslt
					}
					err = cmds.Create(ctx, payloadIn, args.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt
					}
					rslt.CmpdOffset = args.CmpdOffset // for possible delete in rollback
					rslt.Payload, err = proto.Marshal(payloadIn)
					if err != nil {
						rslt.SetResult(err)
						return rslt
					}
				} else { // Direction_REVERSE
					err = cmds.Delete(ctx, args.Key, args.ForwardResult.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt
					}
				}
			}
		case rkcy.READ:
			{
                inst := &{{ $cnc.Name }}{}
				inst, rslt.CmpdOffset, err = cmds.Read(ctx, args.Key)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				rslt.Payload, err = proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
			}
		case rkcy.UPDATE:
			{
				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
				err = cmds.Update(ctx, payloadIn, args.CmpdOffset)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
			}
		case rkcy.DELETE:
			{
				err = cmds.Delete(ctx, args.Key, args.CmpdOffset)
				if err != nil {
					rslt.SetResult(err)
					return rslt
				}
			}
		default:
			rslt.SetResult(fmt.Errorf("Invalid storage command: %s", command))
			return rslt
		}
	} else {
		rslt.SetResult(fmt.Errorf("Invalid system: %d", system))
		return rslt
	}

	return rslt
}

func (*{{ $cnc.Name }}ConcernHandler) DecodeInstance(
	ctx context.Context,
	buffer []byte,
) (string, error) {
	pb := &{{ $cnc.Name }}{}
	err := proto.Unmarshal(buffer, pb)
	if err != nil {
		return "", err
	}
	decoded, err := protojson.Marshal(pb)
	if err != nil {
		return "", err
	}
	return string(decoded), nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeArg(
	ctx context.Context,
	system rkcy.System,
	command string,
	buffer []byte,
) (string, error) {
	switch system {
	case rkcy.System_STORAGE:
		switch command {
		case rkcy.CREATE:
			fallthrough
		case rkcy.READ:
			fallthrough
		case rkcy.UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
		default:
			return "", fmt.Errorf("ArgDecoder invalid command: %d %s", system, command)
		}
	case rkcy.System_PROCESS:
		switch command {
		case rkcy.REFRESH:
			fallthrough
		case rkcy.READ:
			fallthrough
		case rkcy.VALIDATE_CREATE:
			fallthrough
		case rkcy.VALIDATE_UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
{{- range $cnc.Commands }}
		{{- if .HasInput }}
		case "{{ .Name }}":
			{{- if eq .InputType $cnc.Name }}
			return cndHandler.DecodeInstance(ctx, buffer)
			{{ else }}
			{
				pb := &{{ .InputType }}{}
				err := proto.Unmarshal(buffer, pb)
				if err != nil {
					return "", err
				}
				decoded, err := protojson.Marshal(pb)
				if err != nil {
					return "", err
				}
				return string(decoded), nil
			}
			{{- end }}
		{{- end }}
{{- end }}
		default:
			return "", fmt.Errorf("ArgDecoder invalid command: %d %s", system, command)
		}
	default:
		return "", fmt.Errorf("ArgDecoder invalid system: %d", system)
	}
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeResult(
	ctx context.Context,
	system rkcy.System,
	command string,
	buffer []byte,
) (string, error) {
	switch system {
	case rkcy.System_STORAGE:
		switch command {
		case rkcy.CREATE:
			fallthrough
		case rkcy.READ:
			fallthrough
		case rkcy.UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
		default:
			return "", fmt.Errorf("ResultDecoder invalid command: %d %s", system, command)
		}
	case rkcy.System_PROCESS:
		switch command {
		case rkcy.READ:
			fallthrough
		case rkcy.REFRESH:
			fallthrough
		case rkcy.VALIDATE_CREATE:
			fallthrough
		case rkcy.VALIDATE_UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
{{- range $cnc.Commands }}
		{{- if .HasOutput }}
		case "{{ .Name }}":
			{{- if eq .OutputType $cnc.Name }}
			return cncHdlr.DecodeInstance(ctx, buffer)
			{{- else }}
			{
				pb := &{{ .OutputType }}{}
				err := proto.Unmarshal(buffer, pb)
				if err != nil {
					return "", err
				}
				decoded, err := protojson.Marshal(pb)
				if err != nil {
					return "", err
				}
				return string(decoded), nil
			}
			{{- end }}
		{{- end }}
{{- end }}
		default:
			return "", fmt.Errorf("ResultDecoder invalid command: %d %s", system, command)
		}
	default:
		return "", fmt.Errorf("ResultDecoder invalid system: %d", system)
	}
}
// -----------------------------------------------------------------------------
// Concern {{ .Name }} END
// -----------------------------------------------------------------------------
{{- end }}
{{- end }}{{/* if gt (len .Concerns) 0 */}}
