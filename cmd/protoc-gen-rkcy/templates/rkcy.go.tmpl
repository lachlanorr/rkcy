{{ .LeadingComments }}

package {{ $.Package }}

import (
{{- if .HasConcerns }}
	"bytes"
	"context"
	"fmt"
{{ end }}
{{- if .HasConfigs }}
	"google.golang.org/protobuf/encoding/protojson"
{{- end }}
{{- if .HasConfigsOrConcerns }}
	"google.golang.org/protobuf/proto"
{{- end }}
{{- if .HasConcerns }}
	"google.golang.org/protobuf/types/known/timestamppb"
{{- end }}
{{- if .HasConfigsOrConcerns }}

	"github.com/lachlanorr/rocketcycle/pkg/rkcy"
{{- end }}
)
{{- if gt (len .Configs) 0 }}
{{ range $conf := .Configs }}
// -----------------------------------------------------------------------------
// Config {{ $conf.Name }}
// -----------------------------------------------------------------------------
type {{ $conf.Name }}ConfigHandler struct{}

func (conf *{{ $conf.Name }}) Key() string {
	return conf.{{ $conf.Msg.KeyFieldGo }}
}

func (*{{ $conf.Name }}ConfigHandler) GetKey(msg proto.Message) string {
	conf := msg.(*{{ $conf.Name }})
	return conf.Key()
}

func (*{{ $conf.Name }}ConfigHandler) Unmarshal(b []byte) (proto.Message, error) {
	conf := &{{ $conf.Name }}{}
	err := proto.Unmarshal(b, conf)
	if err != nil {
		return nil, err
	}
	return proto.Message(conf), nil
}

func (*{{ $conf.Name }}ConfigHandler) UnmarshalJson(b []byte) (proto.Message, error) {
	conf := &{{ $conf.Name }}{}
	err := protojson.Unmarshal(b, conf)
	if err != nil {
		return nil, err
	}
	return proto.Message(conf), nil
}

func init() {
	rkcy.RegisterComplexConfigHandler("{{ $conf.Name }}", &{{ $conf.Name }}ConfigHandler{})
}

// -----------------------------------------------------------------------------
// Config {{ $conf.Name }} END
// -----------------------------------------------------------------------------
{{- end }}
{{- end }}
{{- if gt (len .Concerns) 0 }}
{{ range $cnc := .Concerns }}
{{- $relArg := "" }}
{{- $relType := "" }}
{{- if $cnc.Related }}
{{- $relArg = printf "related *%s, " $cnc.Related.Msg.Name }}
{{- $relType = printf "*%s, " $cnc.Related.Msg.Name }}
{{- end }}
// -----------------------------------------------------------------------------
// Concern {{ $cnc.Name }}
// -----------------------------------------------------------------------------
func init() {
	rkcy.RegisterConcernHandler(&{{ $cnc.Name }}ConcernHandler{})
}

func (inst *{{ $cnc.Name }}) Key() string {
	return inst.{{ $cnc.Msg.KeyFieldGo }}
}

func Marshal{{ $cnc.Name }}OrPanic(inst *{{ $cnc.Name }}) []byte {
	b, err := proto.Marshal(inst)
	if err != nil {
		panic(err.Error())
	}
	return b
}

func (inst *{{ $cnc.Name }}) PreValidateCreate(ctx context.Context) error {
	if inst.Key() != "" {
		return rkcy.NewError(rkcy.Code_INVALID_ARGUMENT, "Empty Key during PreValidateCreate for {{ $cnc.Name }}")
	}
	return nil
}

func (inst *{{ $cnc.Name }}) PreValidateUpdate(ctx context.Context, updated *{{ $cnc.Name }}) error {
	if updated.Key() == "" || inst.Key() != updated.Key() {
		return rkcy.NewError(rkcy.Code_INVALID_ARGUMENT, "Mismatched Keys during PreValidateUpdate for {{ $cnc.Name }}")
	}
	return nil
}

// LogicHandler Interface
type {{ $cnc.Name }}LogicHandler interface {
	ValidateCreate(ctx context.Context, inst *{{ $cnc.Name }}) (*{{ $cnc.Name }}, error)
	ValidateUpdate(ctx context.Context, original *{{ $cnc.Name }}, updated *{{ $cnc.Name }}) (*{{ $cnc.Name }}, error)
{{- if $cnc.Commands }}
{{ range $cmd := $cnc.Commands }}
	{{ $cmd.Name }}(ctx context.Context, inst *{{ $cnc.Name }}, {{ $relArg }}{{ if $cmd.HasInput }}payload *{{ $cmd.InputType }}{{ end }}) ({{ if $cmd.HasOutput }}*{{ $cmd.OutputType }}, {{ end }}error)
{{- end }}
{{- end }}
}

// CrudHandler Interface
type {{ $cnc.Name }}CrudHandler interface {
	Read(ctx context.Context, key string) (*{{ $cnc.Name }}, {{ $relType }}*rkcy.CompoundOffset, error)
	Create(ctx context.Context, inst *{{ $cnc.Name }}, cmpdOffset *rkcy.CompoundOffset) (*{{ $cnc.Name }}, error)
	Update(ctx context.Context, inst *{{ $cnc.Name }}, {{ $relArg }}cmpdOffset *rkcy.CompoundOffset) error
	Delete(ctx context.Context, key string, cmpdOffset *rkcy.CompoundOffset) error
}

// Concern Handler
type {{ $cnc.Name }}ConcernHandler struct {
	logicHandler {{ $cnc.Name }}LogicHandler
	crudHandlers map[string]{{ $cnc.Name }}CrudHandler
}

func (*{{ $cnc.Name }}ConcernHandler) ConcernName() string {
	return "{{ $cnc.Name }}"
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) SetLogicHandler(handler interface{}) error {
	if cncHdlr.logicHandler != nil {
		return fmt.Errorf("ProcessHandler already registered for {{ $cnc.Name }}ConcernHandler")
	}
	var ok bool
	cncHdlr.logicHandler, ok = handler.({{ $cnc.Name }}LogicHandler)
	if !ok {
		return fmt.Errorf("Invalid interface for {{ $cnc.Name }}ConcernHandler.SetLogicHandler: %T", handler)
	}
	return nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) SetCrudHandler(storageType string, handler interface{}) error {
	cmds, ok := handler.({{ $cnc.Name }}CrudHandler)
	if !ok {
		return fmt.Errorf("Invalid interface for {{ $cnc.Name }}ConcernHandler.SetCrudHandler: %T", handler)
	}
	if cncHdlr.crudHandlers == nil {
		cncHdlr.crudHandlers = make(map[string]{{ $cnc.Name }}CrudHandler)
	}
	_, ok = cncHdlr.crudHandlers[storageType]
	if ok {
		return fmt.Errorf("CrudHandler already registered for %s/{{ $cnc.Name }}ConcernHandler", storageType)
	}
	cncHdlr.crudHandlers[storageType] = cmds
	return nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) ValidateHandlers() bool {
	if cncHdlr.logicHandler == nil {
		return false
	}
	if cncHdlr.crudHandlers == nil || len(cncHdlr.crudHandlers) == 0 {
		return false
	}
	return true
}
{{- if $cnc.Related }}

// -----------------------------------------------------------------------------
// Related handling
// -----------------------------------------------------------------------------
func (rel *{{ $cnc.Related.Msg.Name }}) Key() string {
	return rel.{{ $cnc.Related.Msg.KeyFieldGo }}
}

func {{ $cnc.Name }}GetRelated(instKey string, instanceStore *rkcy.InstanceStore) (*{{ $cnc.Related.Msg.Name }}, []byte, error) {
	rel := &{{ $cnc.Related.Msg.Name }}{}
	relBytes := instanceStore.GetRelated(instKey)
	if relBytes != nil {
		err := proto.Unmarshal(relBytes, rel)
		if err != nil {
			return nil, nil, err
		}
	}
	return rel, relBytes, nil
}

func (inst *{{ $cnc.Name }}) RequestRelatedSteps(instBytes []byte, relBytes []byte) ([]*rkcy.ApecsTxn_Step, error) {
	{{- if $cnc.Related.HasFwdCncs }}
	var steps []*rkcy.ApecsTxn_Step

	payload := rkcy.PackPayloads(instBytes, relBytes)

	{{- range $relFld := $cnc.Related.Fields }}
	{{- if $relFld.TypeMsg.IsConcern }}
	{{- if $relFld.IdFieldGo }}

	// Field: {{ $relFld.NameGo }}
	{
		relReq := &rkcy.RelatedRequest{
			Concern: "{{ $cnc.Name }}",
			Key:     inst.Key(),
			Field:   "{{ $relFld.NameGo }}",
			Payload: payload,
		}
		relReqBytes, err := proto.Marshal(relReq)
		if err != nil {
			return nil, err
		}
		steps = append(steps, &rkcy.ApecsTxn_Step{
			System:  rkcy.System_PROCESS,
			Concern: "{{ $relFld.TypeMsg.Name }}",
			Command: rkcy.REQUEST_RELATED,
			Key:     inst.{{ $relFld.IdFieldGo }},
			Payload: relReqBytes,
		})
	}
	{{- end }}
	{{- end }}
	{{- end }}

	return steps, nil
	{{- else }}
	// No forward related Concerns
	return nil, nil
	{{- end }}
}

func (rel *{{ $cnc.Name }}Related) RefreshRelatedSteps(instBytes []byte, relBytes []byte) ([]*rkcy.ApecsTxn_Step, error) {
	{{- if $cnc.Related.HasRvsCncs }}
	var steps []*rkcy.ApecsTxn_Step

	payload := rkcy.PackPayloads(instBytes, relBytes)
	{{- range $relFld := $cnc.Related.Fields }}
	{{- if $relFld.TypeMsg.IsConcern }}
	{{- if $relFld.RelFieldGo }}
	{{- if $relFld.IsRepeated }}

	// Field: {{ $relFld.NameGo }}
	for _, itm := range rel.{{ $relFld.NameGo }} {
		relRsp := &rkcy.RelatedResponse{
			Concern: "{{ $cnc.Name }}",
			Field:   "{{ $relFld.RelFieldGo }}",
			Payload: payload,
		}
		relRspBytes, err := proto.Marshal(relRsp)
		if err != nil {
			return nil, err
		}
		steps = append(steps, &rkcy.ApecsTxn_Step{
			System:  rkcy.System_PROCESS,
			Concern: "{{ $relFld.TypeMsg.Name }}",
			Command: rkcy.REFRESH_RELATED,
			Key:     itm.Key(),
			Payload: relRspBytes,
		})
	}
	{{- else }}

	if rel.{{ $relFld.NameGo }} != nil {
		relRsp := &rkcy.RelatedResponse{
			Concern: "{{ $cnc.Name }}",
			Field:   "{{ $relFld.RelFieldGo }}",
			Payload: payload,
		}
		relRspBytes, err := proto.Marshal(relRsp)
		if err != nil {
			return nil, err
		}
		steps = append(steps, &rkcy.ApecsTxn_Step{
			System:  rkcy.System_PROCESS,
			Concern: "{{ $relFld.TypeMsg.Name }}",
			Command: rkcy.REFRESH_RELATED,
			Key:     rel.{{ $relFld.NameGo }}.Key(),
			Payload: relRspBytes,
		})
	}
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}

	return steps, nil
	{{- else }}
	// No reverse related Concerns
	return nil, nil
	{{- end }}
}
{{- range $relFld := $cnc.Related.Fields }}
{{- if $relFld.IsRepeated }}

func (rel *{{ $cnc.Name }}Related) UpsertRelated{{ $relFld.NameGo }}(msg *{{ $relFld.TypeMsg.Name }}) {
	idx := -1
	// check to see if it's already here
	for i, itm := range rel.{{ $relFld.NameGo }} {
		if itm.Key() == msg.Key() {
			idx = i
			break
		}
	}
	if idx == -1 {
		rel.{{ $relFld.NameGo }} = append(rel.{{ $relFld.NameGo }}, msg)
	} else {
		rel.{{ $relFld.NameGo }}[idx] = msg
	}
}
{{- end }}
{{- end }}

func (rel *{{ $cnc.Name }}Related) HandleRequestRelated(relReq *rkcy.RelatedRequest) (bool, error) {
	{{- if $cnc.Related.HasPureRelCncs }}
	switch relReq.Field {
	{{- range $relFld := $cnc.Related.Fields }}
	{{- if $relFld.IsPureRelCnc }}
	case "{{ $relFld.RelFieldGo }}":
		if relReq.Concern == "{{ $relFld.TypeMsg.Name }}" {
			instBytes, _, err := rkcy.UnpackPayloads(relReq.Payload)
			if err != nil {
				return false, err
			}
			inst := &{{ $relFld.TypeMsg.Name }}{}
			err = proto.Unmarshal(instBytes, inst)
			if err != nil {
				return false, err
			}
			{{- if $relFld.IsRepeated }}

			rel.UpsertRelated{{ $relFld.NameGo }}(inst)
			{{- else }}

			rel.{{ $relFld.NameGo }} = inst
			{{- end }}
			return true, nil
		} else {
			return false, fmt.Errorf("HandleRequestRelated: Invalid type '%s' for field {{ $relFld.NameGo }}, expecting '{{ $relFld.TypeMsg.Name }}'", relReq.Concern)
		}
	{{- end }}
	{{- end }}
	default:
		return false, fmt.Errorf("HandleRequestRelated: Invalid field '%s''", relReq.Field)
	}
	{{- else }}
	// No 'pure' reverse relations, so no need to capture the contents of this request
	{{- end }}
	return false, nil
}

func (rel *{{ $cnc.Name }}Related) HandleRefreshRelated(relRsp *rkcy.RelatedResponse) (bool, error) {
	switch relRsp.Field {
	{{- range $relFld := $cnc.Related.Fields }}
	{{- if $relFld.TypeMsg.IsConcern }}
	case "{{ $relFld.NameGo }}":
		if relRsp.Concern == "{{ $relFld.TypeMsg.Name }}" {
			instBytes, _, err := rkcy.UnpackPayloads(relRsp.Payload)
			if err != nil {
				return false, err
			}
			inst := &{{ $relFld.TypeMsg.Name }}{}
			err = proto.Unmarshal(instBytes, inst)
			if err != nil {
				return false, err
			}
			{{- if $relFld.IsRepeated }}

			rel.UpsertRelated{{ $relFld.NameGo }}(inst)
			{{- else }}

			rel.{{ $relFld.NameGo }} = inst
			{{- end }}
			return true, nil
		} else {
			return false, fmt.Errorf("HandleRefreshRelated: Invalid type '%s' for field {{ $relFld.NameGo }}, expecting '{{ $relFld.TypeMsg.Name }}'", relRsp.Concern)
		}
	{{- end }}
	{{- end }}
	default:
		return false, fmt.Errorf("HandleRefreshRelated: Invalid field '%s''", relRsp.Field)
	}
}

// -----------------------------------------------------------------------------
// Related handling (END)
// -----------------------------------------------------------------------------
{{- end }}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) HandleCommand(
	ctx context.Context,
	system rkcy.System,
	command string,
	direction rkcy.Direction,
	args *rkcy.StepArgs,
	instanceStore *rkcy.InstanceStore,
	confRdr *rkcy.ConfigRdr,
	storageType string,
) (*rkcy.ApecsTxn_Step_Result, []*rkcy.ApecsTxn_Step) {
	var err error
	rslt := &rkcy.ApecsTxn_Step_Result{}
	var addSteps []*rkcy.ApecsTxn_Step // additional steps we want to be run after us

	if direction == rkcy.Direction_REVERSE && args.ForwardResult == nil {
		rslt.SetResult(fmt.Errorf("Unable to reverse step with nil ForwardResult"))
		return rslt, nil
	}

	if system == rkcy.System_PROCESS {
		switch command {
		// process handlers
		case rkcy.CREATE:
			rslt.SetResult(fmt.Errorf("Invalid process command: %s", command))
			return rslt, nil
		case rkcy.READ:
			if direction == rkcy.Direction_FORWARD {
				related := instanceStore.GetRelated(args.Key)
				rslt.Payload = rkcy.PackPayloads(args.Instance, related)
			} else { // Direction_REVERSE
				panic("REVERSE not implemented")
			}
		case rkcy.UPDATE:
			if direction == rkcy.Direction_FORWARD {
				if !bytes.Equal(args.Payload, args.Instance) {
					{{- if $cnc.Related }}
					rel, relBytes, err := {{ $cnc.Name }}GetRelated(args.Key, instanceStore)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					relSteps, err := rel.RefreshRelatedSteps(args.Payload, relBytes)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					if relSteps != nil {
						addSteps = append(addSteps, relSteps...)
					}
					{{- end }}
					rslt.Instance = args.Payload
				}
			} else { // Direction_REVERSE
				panic("REVERSE not implemented")
			}
		case rkcy.DELETE:
			if direction == rkcy.Direction_FORWARD {
				instanceStore.Remove(args.Key)
			} else { // Direction_REVERSE
				panic("REVERSE not implemented")
			}
		case rkcy.VALIDATE_CREATE:
			{
				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				err = payloadIn.PreValidateCreate(ctx)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				payloadOut, err := cncHdlr.logicHandler.ValidateCreate(ctx, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
			}
		case rkcy.VALIDATE_UPDATE:
			{
				if args.Instance == nil {
					rslt.SetResult(fmt.Errorf("No instance exists during VALIDATE_UPDATE"))
					return rslt, nil
				}
				inst := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Instance, inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}

				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				err = inst.PreValidateUpdate(ctx, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				payloadOut, err := cncHdlr.logicHandler.ValidateUpdate(ctx, inst, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}

				// compare inst to see if it has changed
				instSer, err := proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				if !bytes.Equal(instSer, args.Instance) {
					{{- if $cnc.Related }}
					rel, relBytes, err := {{ $cnc.Name }}GetRelated(args.Key, instanceStore)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					relSteps, err := rel.RefreshRelatedSteps(instSer, relBytes)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					if relSteps != nil {
						addSteps = append(addSteps, relSteps...)
					}
					{{- end }}
					rslt.Instance = instSer
				}
			}
		{{- if $cnc.Related }}
		case rkcy.REQUEST_RELATED:
			{
				relReq := &rkcy.RelatedRequest{}
				err := proto.Unmarshal(args.Payload, relReq)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				// Get our related concerns from instanceStore
				rel, _, err := {{ $cnc.Name }}GetRelated(args.Key, instanceStore)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				// Handle refresh related request to see if it fulfills any of our related items
				changed, err := rel.HandleRequestRelated(relReq)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				relBytes, err := proto.Marshal(rel)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				relPayload := rkcy.PackPayloads(args.Instance, relBytes)
				if changed {
					err = instanceStore.SetRelated(args.Key, relBytes, args.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
				}
				// Send response containing our instance
				relRsp := &rkcy.RelatedResponse{
					Concern: "{{ $cnc.Name }}",
					Field:   relReq.Field,
					Payload: relPayload,
				}
				relRspBytes, err := proto.Marshal(relRsp)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				addSteps = append(
					addSteps,
					&rkcy.ApecsTxn_Step{
						System:        rkcy.System_PROCESS,
						Concern:       relReq.Concern,
						Command:       rkcy.REFRESH_RELATED,
						Key:           relReq.Key,
						Payload:       relRspBytes,
						EffectiveTime: timestamppb.Now(),
					},
				)
				rslt.Payload = relRspBytes
			}
		case rkcy.REFRESH_RELATED:
			{
				relRsp := &rkcy.RelatedResponse{}
				err := proto.Unmarshal(args.Payload, relRsp)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				// Get our related concerns from instanceStore
				rel, _, err := {{ $cnc.Name }}GetRelated(args.Key, instanceStore)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				// Handle refresh related response
				changed, err := rel.HandleRefreshRelated(relRsp) // dummy
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				relBytes, err := proto.Marshal(rel)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				if changed {
					err = instanceStore.SetRelated(args.Key, relBytes, args.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
				}
				rslt.Payload = rkcy.PackPayloads(args.Instance, relBytes)
			}
		{{- end }}
{{- range $cnc.Commands }}
		case "{{ .Name }}":
			{
				if args.Instance == nil {
					rslt.SetResult(fmt.Errorf("No instance exists during HandleCommand"))
					return rslt, nil
				}
				inst := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Instance, inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}

				{{- if $cnc.Related }}
				rel, _, err := {{ $cnc.Name }}GetRelated(inst.Key(), instanceStore)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- end }}
				{{- if .HasInput }}
				payloadIn := &{{ .InputType }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- end }}
				{{ if .HasOutput }}payloadOut, {{ end }}err := cncHdlr.logicHandler.{{ .Name }}(ctx, inst{{ if $cnc.Related }}, rel{{ end }}{{ if .HasInput }}, payloadIn{{ end }})
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- if .HasOutput }}
				rslt.Payload, err = proto.Marshal(payloadOut)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- end }}

				// compare inst to see if it has changed
				instSer, err := proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				if !bytes.Equal(instSer, args.Instance) {
					rslt.Instance = instSer
				}
			}
{{- end }}
		default:
			rslt.SetResult(fmt.Errorf("Invalid process command: %s", command))
			return rslt, nil
		}
	} else if system == rkcy.System_STORAGE {
		// Quick out for REVERSE mode on non CREATE commands, this should never happen
		if direction == rkcy.Direction_REVERSE && command != rkcy.CREATE {
			rslt.SetResult(fmt.Errorf("Unable to reverse non CREATE storage commands"))
			return rslt, nil
		}

		handler, ok := cncHdlr.crudHandlers[storageType]
		if !ok {
			rslt.SetResult(fmt.Errorf("No CrudHandler for %s", storageType))
			return rslt, nil
		}

		switch command {
		// storage handlers
		case rkcy.CREATE:
			{
				if direction == rkcy.Direction_FORWARD {
					payloadIn := &{{ $cnc.Name }}{}
					err = proto.Unmarshal(args.Payload, payloadIn)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					payloadOut, err := handler.Create(ctx, payloadIn, args.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
					// NOTE: From this point on any error handler must attempt to
					// Delete from the datastore, if this step fails, a reversal
					// step will not be run, so we must ensure we do it here.
					if payloadOut.Key() == "" {
						err := fmt.Errorf("No Key set in CREATE {{ $cnc.Name }}")
						errDel := handler.Delete(ctx, payloadOut.Key(), args.CmpdOffset)
						if errDel != nil {
							rslt.SetResult(fmt.Errorf("DELETE error cleaning up CREATE failure, orig err: '%s', DELETE err: '%s'", err.Error(), errDel.Error()))
							return rslt, nil
						}
						rslt.SetResult(fmt.Errorf("No Key set in CREATE {{ $cnc.Name }}"))
						return rslt, nil
					}
					rslt.Key = payloadOut.Key()
					rslt.CmpdOffset = args.CmpdOffset // for possible delete in rollback
					rslt.Payload, err = proto.Marshal(payloadOut)
					if err != nil {
						errDel := handler.Delete(ctx, payloadOut.Key(), args.CmpdOffset)
						if errDel != nil {
							rslt.SetResult(fmt.Errorf("DELETE error cleaning up CREATE failure, orig err: '%s', DELETE err: '%s'", err.Error(), errDel.Error()))
							return rslt, nil
						}
						rslt.SetResult(err)
						return rslt, nil
					}
					// Add a refresh step which will update the instance cache
					addSteps = append(
						addSteps,
						&rkcy.ApecsTxn_Step{
							System:        rkcy.System_PROCESS,
							Concern:       "{{ $cnc.Name }}",
							Command:       rkcy.REFRESH_INSTANCE,
							Key:           rslt.Key,
							Payload:       rkcy.PackPayloads(rslt.Payload, nil /* should be related */),
							EffectiveTime: timestamppb.New(args.EffectiveTime),
						},
					)
					{{- if $cnc.Related }}
					// Request related refresh messages from our related concerns
					relSteps, err := payloadOut.RequestRelatedSteps(rslt.Payload, nil)
					if err != nil {
						errDel := handler.Delete(ctx, payloadOut.Key(), args.CmpdOffset)
						if errDel != nil {
							rslt.SetResult(fmt.Errorf("DELETE error cleaning up CREATE failure, orig err: '%s', DELETE err: '%s'", err.Error(), errDel.Error()))
							return rslt, nil
						}
						rslt.SetResult(err)
						return rslt, nil
					}
					if relSteps != nil {
						addSteps = append(addSteps, relSteps...)
					}
					{{- end }}
				} else { // Direction_REVERSE
					err = handler.Delete(ctx, args.Key, args.ForwardResult.CmpdOffset)
					if err != nil {
						rslt.SetResult(err)
						return rslt, nil
					}
				}
			}
		case rkcy.READ:
			{
				var inst *{{ $cnc.Name }}
				{{- if $cnc.Related }}
				var rel *{{ $cnc.Related.Msg.Name }}
				{{- end }}
				inst, {{ if $cnc.Related }}rel, {{ end }}rslt.CmpdOffset, err = handler.Read(ctx, args.Key)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				instBytes, err := proto.Marshal(inst)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				var relBytes []byte
				{{- if $cnc.Related }}
				relBytes, err = proto.Marshal(rel)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- end }}
				rslt.Payload = rkcy.PackPayloads(instBytes, relBytes)
				addSteps = append(
					addSteps,
					&rkcy.ApecsTxn_Step{
						System:        rkcy.System_PROCESS,
						Concern:       "{{ $cnc.Name }}",
						Command:       rkcy.REFRESH_INSTANCE,
						Key:           inst.Key(),
						Payload:       rslt.Payload,
						EffectiveTime: timestamppb.New(args.EffectiveTime),
					},
				)
			}
		case rkcy.UPDATE:
			{
				payloadIn := &{{ $cnc.Name }}{}
				err = proto.Unmarshal(args.Payload, payloadIn)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- if $cnc.Related }}
				rel, _, err := {{ $cnc.Name }}GetRelated(payloadIn.Key(), instanceStore)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
				{{- end }}
				err = handler.Update(ctx, payloadIn, {{ if $cnc.Related }}rel, {{ end }}args.CmpdOffset)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
			}
		case rkcy.DELETE:
			{
				err = handler.Delete(ctx, args.Key, args.CmpdOffset)
				if err != nil {
					rslt.SetResult(err)
					return rslt, nil
				}
			}
		default:
			rslt.SetResult(fmt.Errorf("Invalid storage command: %s", command))
			return rslt, nil
		}
	} else {
		rslt.SetResult(fmt.Errorf("Invalid system: %d", system))
		return rslt, nil
	}

	return rslt, addSteps
}

func (*{{ $cnc.Name }}ConcernHandler) DecodeInstance(
	ctx context.Context,
	buffer []byte,
) (*rkcy.ResultProto, error) {
	resProto := &rkcy.ResultProto{
		Type: "{{ $cnc.Name }}",
	}

	if !rkcy.IsPackedPayload(buffer) {
		inst := &{{ $cnc.Name }}{}
		err := proto.Unmarshal(buffer, inst)
		if err != nil {
			return nil, err
		}
		resProto.Instance = inst
	} else {
		instBytes, {{ if $cnc.Related }}relBytes{{ else }}_{{ end }}, err := rkcy.UnpackPayloads(buffer)
		if err != nil {
			return nil, err
		}

		inst := &{{ $cnc.Name }}{}
		err = proto.Unmarshal(instBytes, inst)
		if err != nil {
			return nil, err
		}
		resProto.Instance = inst
		{{- if $cnc.Related }}

		if relBytes != nil && len(relBytes) > 0 {
			rel := &{{ $cnc.Name }}Related{}
			err := proto.Unmarshal(relBytes, rel)
			if err != nil {
				return nil, err
			}
			resProto.Related = rel
		}
		{{- end }}
	}

	return resProto, nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeArg(
	ctx context.Context,
	system rkcy.System,
	command string,
	buffer []byte,
) (*rkcy.ResultProto, error) {
	switch system {
	case rkcy.System_STORAGE:
		switch command {
		case rkcy.CREATE:
			fallthrough
		case rkcy.READ:
			fallthrough
		case rkcy.UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
		default:
			return nil, fmt.Errorf("ArgDecoder invalid command: %d %s", system, command)
		}
	case rkcy.System_PROCESS:
		switch command {
		case rkcy.VALIDATE_CREATE:
			fallthrough
		case rkcy.VALIDATE_UPDATE:
			fallthrough
		case rkcy.REFRESH_INSTANCE:
			return cncHdlr.DecodeInstance(ctx, buffer)
		case rkcy.REQUEST_RELATED:
			{
				relReq := &rkcy.RelatedRequest{}
				err := proto.Unmarshal(buffer, relReq)
				if err != nil {
					return nil, err
				}
				return &rkcy.ResultProto{Type: "RelatedRequest", Instance: relReq}, nil
			}
		case rkcy.REFRESH_RELATED:
			{
				relRsp := &rkcy.RelatedResponse{}
				err := proto.Unmarshal(buffer, relRsp)
				if err != nil {
					return nil, err
				}
				return &rkcy.ResultProto{Type: "RelatedResponse", Instance: relRsp}, nil
			}
{{- range $cnc.Commands }}
		{{- if .HasInput }}
		case "{{ .Name }}":
			{
				pb := &{{ .InputType }}{}
				err := proto.Unmarshal(buffer, pb)
				if err != nil {
					return nil, err
				}
				return &rkcy.ResultProto{Type: "{{ .InputType }}", Instance: pb}, nil
			}
		{{- end }}
{{- end }}
		default:
			return nil, fmt.Errorf("ArgDecoder invalid command: %d %s", system, command)
		}
	default:
		return nil, fmt.Errorf("ArgDecoder invalid system: %d", system)
	}
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeResult(
	ctx context.Context,
	system rkcy.System,
	command string,
	buffer []byte,
) (*rkcy.ResultProto, error) {
	switch system {
	case rkcy.System_STORAGE:
		switch command {
		case rkcy.READ:
			fallthrough
		case rkcy.CREATE:
			fallthrough
		case rkcy.UPDATE:
			return cncHdlr.DecodeInstance(ctx, buffer)
		default:
			return nil, fmt.Errorf("ResultDecoder invalid command: %d %s", system, command)
		}
	case rkcy.System_PROCESS:
		switch command {
		case rkcy.READ:
			fallthrough
		case rkcy.VALIDATE_CREATE:
			fallthrough
		case rkcy.VALIDATE_UPDATE:
			fallthrough
		case rkcy.REFRESH_INSTANCE:
			fallthrough
		case rkcy.REFRESH_RELATED:
			return cncHdlr.DecodeInstance(ctx, buffer)
		case rkcy.REQUEST_RELATED:
			{
				relRsp := &rkcy.RelatedResponse{}
				err := proto.Unmarshal(buffer, relRsp)
				if err != nil {
					return nil, err
				}
				return &rkcy.ResultProto{Type: "RelatedResponse", Instance: relRsp}, nil
			}
{{- range $cnc.Commands }}
		{{- if .HasOutput }}
		case "{{ .Name }}":
			{
				pb := &{{ .OutputType }}{}
				err := proto.Unmarshal(buffer, pb)
				if err != nil {
					return nil, err
				}
				return &rkcy.ResultProto{Type: "{{ .OutputType }}", Instance: pb}, nil
			}
		{{- end }}
{{- end }}
		default:
			return nil, fmt.Errorf("ResultDecoder invalid command: %d %s", system, command)
		}
	default:
		return nil, fmt.Errorf("ResultDecoder invalid system: %d", system)
	}
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeRelatedRequest(
	ctx context.Context,
	relReq *rkcy.RelatedRequest,
) (*rkcy.ResultProto, error) {
	return &rkcy.ResultProto{
		Type: "{{ $cnc.Name }} Note: need to add this to codegen!!!",
	}, nil
}

func (cncHdlr *{{ $cnc.Name }}ConcernHandler) DecodeRelatedResponse(
	ctx context.Context,
	relRsp *rkcy.RelatedResponse,
) (*rkcy.ResultProto, error) {
	return &rkcy.ResultProto{
		Type: "{{ $cnc.Name }} Note: need to add this to codegen!!!",
	}, nil
}

// -----------------------------------------------------------------------------
// Concern {{ .Name }} END
// -----------------------------------------------------------------------------
{{- end }}
{{- end }}{{/* if gt (len .Concerns) 0 */}}
